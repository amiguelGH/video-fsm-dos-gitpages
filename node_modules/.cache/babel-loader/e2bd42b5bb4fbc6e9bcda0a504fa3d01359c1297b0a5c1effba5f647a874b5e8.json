{"ast":null,"code":"import { T as ProcessingStatus, z as resolveReferencedActor, A as createActor, U as cloneMachineSnapshot, V as XSTATE_ERROR, W as createErrorActorEvent, e as evaluateGuard, M as cancel, O as raise, P as spawnChild, R as stopChild } from './raise-29904799.esm.js';\n\n// it's likely-ish that `(TActor & { src: TSrc })['logic']` would be faster\n// but it's only possible to do it since https://github.com/microsoft/TypeScript/pull/53098 (TS 5.1)\n// and we strive to support TS 5.0 whenever possible\nfunction createSpawner(actorScope, _ref, event, spawnedChildren) {\n  let {\n    machine,\n    context\n  } = _ref;\n  const spawn = function (src) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      systemId,\n      input\n    } = options;\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n      if (!logic) {\n        throw new Error(\"Actor logic '\".concat(src, \"' not implemented in machine '\").concat(machine.id, \"'\"));\n      }\n      const actorRef = createActor(logic, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: typeof input === 'function' ? input({\n          context,\n          event,\n          self: actorScope.self\n        }) : input,\n        src,\n        systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: options.input,\n        src,\n        systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, _ref2) {\n  let {\n    assignment\n  } = _ref2;\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [cloneMachineSnapshot(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  })];\n}\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update, or a\n * function that returns an object that represents the partial context to update.\n *\n * @example\n  ```ts\n  import { createMachine, assign } from 'xstate';\n\n  const countMachine = createMachine({\n    context: {\n      count: 0,\n      message: ''\n    },\n    on: {\n      inc: {\n        actions: assign({\n          count: ({ context }) => context.count + 1\n        })\n      },\n      updateMessage: {\n        actions: assign(({ context, event }) => {\n          return {\n            message: event.message.trim()\n          }\n        })\n      }\n    }\n  });\n  ```\n */\nfunction assign(assignment) {\n  function assign(args, params) {}\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\nfunction resolveEmit(_, snapshot, args, actionParams, _ref3) {\n  let {\n    event: eventOrExpr\n  } = _ref3;\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }];\n}\nfunction executeEmit(actorScope, _ref4) {\n  let {\n    event\n  } = _ref4;\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event, handler)`.\n *\n * @example\n  ```ts\n  import { emit } from 'xstate';\n\n  const machine = createMachine({\n    // ...\n    on: {\n      something: {\n        actions: emit({\n          type: 'emitted',\n          some: 'data'\n        })\n      }\n    }\n    // ...\n  });\n\n  const actor = createActor(machine).start();\n\n  actor.on('emitted', (event) => {\n    console.log(event);\n  });\n\n  actor.send({ type: 'something' });\n  // logs:\n  // {\n  //   type: 'emitted',\n  //   some: 'data'\n  // }\n  ```\n */\nfunction emit(\n/**\n * The event to emit, or an expression that returns an event to emit.\n */\neventOrExpr) {\n  function emit(args, params) {}\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n/**\n *\n * @remarks\n *\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.\n * It especially is a problem when the union has a function member, like here:\n *\n * ```ts\n * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;\n * test((arg) => {}) // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n/**\n * @deprecated Use the built-in `NoInfer` type instead\n */\n/**\n * The full definition of an event, with a string `type`.\n */\n/**\n * The string or object representing the state value relative to the parent state node.\n *\n * @remarks\n *\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n *\n * - For complex state nodes, this is an object, e.g., `{ success: \"someChildState\" }`.\n */\n// TODO: remove once TS fixes this type-widening issue\n/** @deprecated use `AnyMachineSnapshot` instead */\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/**\n * @hidden\n */\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/**\n * @deprecated Use `AnyActor` instead.\n */\n\n// Based on RxJS types\n\n/**\n * @deprecated Use `Actor<T>` instead.\n */\n\n// only meant to be used internally for debugging purposes\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, _ref5, extra) {\n  let {\n    to,\n    event: eventOrExpr,\n    id,\n    delay\n  } = _ref5;\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(\"Only event objects may be used with sendTo; use sendTo({ type: \\\"\".concat(eventOrExpr, \"\\\" }) instead\"));\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      var _extra$deferredActorI;\n      targetActorRef = (_extra$deferredActorI = extra.deferredActorIds) !== null && _extra$deferredActorI !== void 0 && _extra$deferredActorI.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(\"Unable to send event to actor '\".concat(resolvedTarget, \"' from machine '\").concat(snapshot.machine.id, \"'.\"));\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event to send\n * @param options Send action options\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  function sendTo(args, params) {}\n  sendTo.type = 'xsnapshot.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options === null || options === void 0 ? void 0 : options.id;\n  sendTo.delay = options === null || options === void 0 ? void 0 : options.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  return sendTo(target, _ref6 => {\n    let {\n      event\n    } = _ref6;\n    return event;\n  }, options);\n}\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, _ref7) {\n  let {\n    collect\n  } = _ref7;\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = function () {\n    actions.push(assign(...arguments));\n  };\n  enqueue.cancel = function () {\n    actions.push(cancel(...arguments));\n  };\n  enqueue.raise = function () {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push(raise(...arguments));\n  };\n  enqueue.sendTo = function () {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...arguments));\n  };\n  enqueue.spawnChild = function () {\n    actions.push(spawnChild(...arguments));\n  };\n  enqueue.stopChild = function () {\n    actions.push(stopChild(...arguments));\n  };\n  enqueue.emit = function () {\n    actions.push(emit(...arguments));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => evaluateGuard(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the `enqueue(action)` function.\n *\n * @example\n  ```ts\n  import { createMachine, enqueueActions } from 'xstate';\n\n  const machine = createMachine({\n    entry: enqueueActions(({ enqueue, check }) => {\n      enqueue.assign({ count: 0 });\n\n      if (check('someGuard')) {\n        enqueue.assign({ count: 1 });\n      }\n\n      enqueue('someAction');\n    })\n  })\n  ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(args, params) {}\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\nfunction resolveLog(_, snapshot, actionArgs, actionParams, _ref8) {\n  let {\n    value,\n    label\n  } = _ref8;\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }];\n}\nfunction executeLog(_ref9, _ref10) {\n  let {\n    logger\n  } = _ref9;\n  let {\n    value,\n    label\n  } = _ref10;\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\nfunction log() {\n  let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _ref11 => {\n    let {\n      context,\n      event\n    } = _ref11;\n    return {\n      context,\n      event\n    };\n  };\n  let label = arguments.length > 1 ? arguments[1] : undefined;\n  function log(args, params) {}\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\nexport { SpecialTargets as S, assign as a, enqueueActions as b, sendTo as c, emit as e, forwardTo as f, log as l, sendParent as s };","map":{"version":3,"names":["T","ProcessingStatus","z","resolveReferencedActor","A","createActor","U","cloneMachineSnapshot","V","XSTATE_ERROR","W","createErrorActorEvent","e","evaluateGuard","M","cancel","O","raise","P","spawnChild","R","stopChild","createSpawner","actorScope","_ref","event","spawnedChildren","machine","context","spawn","src","options","arguments","length","undefined","systemId","input","logic","Error","concat","id","actorRef","parent","self","syncSnapshot","defer","_processingStatus","Stopped","start","resolveAssign","snapshot","actionArgs","actionParams","_ref2","assignment","assignArgs","system","partialUpdate","key","Object","keys","propAssignment","updatedContext","assign","children","args","params","type","resolve","resolveEmit","_","_ref3","eventOrExpr","resolvedEvent","executeEmit","_ref4","emit","execute","SpecialTargets","resolveSendTo","_ref5","extra","to","delay","delaysMap","implementations","delays","resolvedDelay","configDelay","resolvedTarget","targetActorRef","Parent","_parent","Internal","startsWith","slice","_extra$deferredActorI","deferredActorIds","includes","retryResolveSendTo","executeSendTo","scheduler","schedule","_relay","data","sendTo","retryResolve","sendParent","forwardTo","target","_ref6","resolveEnqueueActions","_ref7","collect","actions","enqueue","action","push","check","guard","enqueueActions","resolveLog","_ref8","value","label","executeLog","_ref9","_ref10","logger","log","_ref11","S","a","b","c","f","l","s"],"sources":["C:/PoC-FE/video-fsm-dos-gitpages/node_modules/xstate/dist/log-86c89339.esm.js"],"sourcesContent":["import { T as ProcessingStatus, z as resolveReferencedActor, A as createActor, U as cloneMachineSnapshot, V as XSTATE_ERROR, W as createErrorActorEvent, e as evaluateGuard, M as cancel, O as raise, P as spawnChild, R as stopChild } from './raise-29904799.esm.js';\n\n// it's likely-ish that `(TActor & { src: TSrc })['logic']` would be faster\n// but it's only possible to do it since https://github.com/microsoft/TypeScript/pull/53098 (TS 5.1)\n// and we strive to support TS 5.0 whenever possible\nfunction createSpawner(actorScope, {\n  machine,\n  context\n}, event, spawnedChildren) {\n  const spawn = (src, options = {}) => {\n    const {\n      systemId,\n      input\n    } = options;\n    if (typeof src === 'string') {\n      const logic = resolveReferencedActor(machine, src);\n      if (!logic) {\n        throw new Error(`Actor logic '${src}' not implemented in machine '${machine.id}'`);\n      }\n      const actorRef = createActor(logic, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: typeof input === 'function' ? input({\n          context,\n          event,\n          self: actorScope.self\n        }) : input,\n        src,\n        systemId\n      });\n      spawnedChildren[actorRef.id] = actorRef;\n      return actorRef;\n    } else {\n      const actorRef = createActor(src, {\n        id: options.id,\n        parent: actorScope.self,\n        syncSnapshot: options.syncSnapshot,\n        input: options.input,\n        src,\n        systemId\n      });\n      return actorRef;\n    }\n  };\n  return (src, options) => {\n    const actorRef = spawn(src, options); // TODO: fix types\n    spawnedChildren[actorRef.id] = actorRef;\n    actorScope.defer(() => {\n      if (actorRef._processingStatus === ProcessingStatus.Stopped) {\n        return;\n      }\n      actorRef.start();\n    });\n    return actorRef;\n  };\n}\n\nfunction resolveAssign(actorScope, snapshot, actionArgs, actionParams, {\n  assignment\n}) {\n  if (!snapshot.context) {\n    throw new Error('Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.');\n  }\n  const spawnedChildren = {};\n  const assignArgs = {\n    context: snapshot.context,\n    event: actionArgs.event,\n    spawn: createSpawner(actorScope, snapshot, actionArgs.event, spawnedChildren),\n    self: actorScope.self,\n    system: actorScope.system\n  };\n  let partialUpdate = {};\n  if (typeof assignment === 'function') {\n    partialUpdate = assignment(assignArgs, actionParams);\n  } else {\n    for (const key of Object.keys(assignment)) {\n      const propAssignment = assignment[key];\n      partialUpdate[key] = typeof propAssignment === 'function' ? propAssignment(assignArgs, actionParams) : propAssignment;\n    }\n  }\n  const updatedContext = Object.assign({}, snapshot.context, partialUpdate);\n  return [cloneMachineSnapshot(snapshot, {\n    context: updatedContext,\n    children: Object.keys(spawnedChildren).length ? {\n      ...snapshot.children,\n      ...spawnedChildren\n    } : snapshot.children\n  })];\n}\n/**\n * Updates the current context of the machine.\n *\n * @param assignment An object that represents the partial context to update, or a\n * function that returns an object that represents the partial context to update.\n *\n * @example\n  ```ts\n  import { createMachine, assign } from 'xstate';\n\n  const countMachine = createMachine({\n    context: {\n      count: 0,\n      message: ''\n    },\n    on: {\n      inc: {\n        actions: assign({\n          count: ({ context }) => context.count + 1\n        })\n      },\n      updateMessage: {\n        actions: assign(({ context, event }) => {\n          return {\n            message: event.message.trim()\n          }\n        })\n      }\n    }\n  });\n  ```\n */\nfunction assign(assignment) {\n  function assign(args, params) {\n  }\n  assign.type = 'xstate.assign';\n  assign.assignment = assignment;\n  assign.resolve = resolveAssign;\n  return assign;\n}\n\nfunction resolveEmit(_, snapshot, args, actionParams, {\n  event: eventOrExpr\n}) {\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  return [snapshot, {\n    event: resolvedEvent\n  }];\n}\nfunction executeEmit(actorScope, {\n  event\n}) {\n  actorScope.defer(() => actorScope.emit(event));\n}\n/**\n * Emits an event to event handlers registered on the actor via `actor.on(event, handler)`.\n *\n * @example\n  ```ts\n  import { emit } from 'xstate';\n\n  const machine = createMachine({\n    // ...\n    on: {\n      something: {\n        actions: emit({\n          type: 'emitted',\n          some: 'data'\n        })\n      }\n    }\n    // ...\n  });\n\n  const actor = createActor(machine).start();\n\n  actor.on('emitted', (event) => {\n    console.log(event);\n  });\n\n  actor.send({ type: 'something' });\n  // logs:\n  // {\n  //   type: 'emitted',\n  //   some: 'data'\n  // }\n  ```\n */\nfunction emit(\n/**\n * The event to emit, or an expression that returns an event to emit.\n */\neventOrExpr) {\n  function emit(args, params) {\n  }\n  emit.type = 'xstate.emit';\n  emit.event = eventOrExpr;\n  emit.resolve = resolveEmit;\n  emit.execute = executeEmit;\n  return emit;\n}\n\n/**\n *\n * @remarks\n *\n * `T | unknown` reduces to `unknown` and that can be problematic when it comes to contextual typing.\n * It especially is a problem when the union has a function member, like here:\n *\n * ```ts\n * declare function test(cbOrVal: ((arg: number) => unknown) | unknown): void;\n * test((arg) => {}) // oops, implicit any\n * ```\n *\n * This type can be used to avoid this problem. This union represents the same value space as `unknown`.\n */\n\n// https://github.com/microsoft/TypeScript/issues/23182#issuecomment-379091887\n\n// @TODO: Replace with native `NoInfer` when TS issue gets fixed:\n// https://github.com/microsoft/TypeScript/pull/57673\n/**\n * @deprecated Use the built-in `NoInfer` type instead\n */\n/**\n * The full definition of an event, with a string `type`.\n */\n/**\n * The string or object representing the state value relative to the parent state node.\n *\n * @remarks\n *\n * - For a child atomic state node, this is a string, e.g., `\"pending\"`.\n *\n * - For complex state nodes, this is an object, e.g., `{ success: \"someChildState\" }`.\n */\n// TODO: remove once TS fixes this type-widening issue\n/** @deprecated use `AnyMachineSnapshot` instead */\n// TODO: possibly refactor this somehow, use even a simpler type, and maybe even make `machine.options` private or something\n/**\n * @hidden\n */\nlet SpecialTargets = /*#__PURE__*/function (SpecialTargets) {\n  SpecialTargets[\"Parent\"] = \"#_parent\";\n  SpecialTargets[\"Internal\"] = \"#_internal\";\n  return SpecialTargets;\n}({});\n\n/**\n * @deprecated Use `AnyActor` instead.\n */\n\n// Based on RxJS types\n\n/**\n * @deprecated Use `Actor<T>` instead.\n */\n\n// only meant to be used internally for debugging purposes\n\n/**\n * Represents logic which can be used by an actor.\n *\n * @template TSnapshot - The type of the snapshot.\n * @template TEvent - The type of the event object.\n * @template TInput - The type of the input.\n * @template TSystem - The type of the actor system.\n */\n\nfunction resolveSendTo(actorScope, snapshot, args, actionParams, {\n  to,\n  event: eventOrExpr,\n  id,\n  delay\n}, extra) {\n  const delaysMap = snapshot.machine.implementations.delays;\n  if (typeof eventOrExpr === 'string') {\n    throw new Error(`Only event objects may be used with sendTo; use sendTo({ type: \"${eventOrExpr}\" }) instead`);\n  }\n  const resolvedEvent = typeof eventOrExpr === 'function' ? eventOrExpr(args, actionParams) : eventOrExpr;\n  let resolvedDelay;\n  if (typeof delay === 'string') {\n    const configDelay = delaysMap && delaysMap[delay];\n    resolvedDelay = typeof configDelay === 'function' ? configDelay(args, actionParams) : configDelay;\n  } else {\n    resolvedDelay = typeof delay === 'function' ? delay(args, actionParams) : delay;\n  }\n  const resolvedTarget = typeof to === 'function' ? to(args, actionParams) : to;\n  let targetActorRef;\n  if (typeof resolvedTarget === 'string') {\n    if (resolvedTarget === SpecialTargets.Parent) {\n      targetActorRef = actorScope.self._parent;\n    } else if (resolvedTarget === SpecialTargets.Internal) {\n      targetActorRef = actorScope.self;\n    } else if (resolvedTarget.startsWith('#_')) {\n      // SCXML compatibility: https://www.w3.org/TR/scxml/#SCXMLEventProcessor\n      // #_invokeid. If the target is the special term '#_invokeid', where invokeid is the invokeid of an SCXML session that the sending session has created by <invoke>, the Processor must add the event to the external queue of that session.\n      targetActorRef = snapshot.children[resolvedTarget.slice(2)];\n    } else {\n      targetActorRef = extra.deferredActorIds?.includes(resolvedTarget) ? resolvedTarget : snapshot.children[resolvedTarget];\n    }\n    if (!targetActorRef) {\n      throw new Error(`Unable to send event to actor '${resolvedTarget}' from machine '${snapshot.machine.id}'.`);\n    }\n  } else {\n    targetActorRef = resolvedTarget || actorScope.self;\n  }\n  return [snapshot, {\n    to: targetActorRef,\n    event: resolvedEvent,\n    id,\n    delay: resolvedDelay\n  }];\n}\nfunction retryResolveSendTo(_, snapshot, params) {\n  if (typeof params.to === 'string') {\n    params.to = snapshot.children[params.to];\n  }\n}\nfunction executeSendTo(actorScope, params) {\n  // this forms an outgoing events queue\n  // thanks to that the recipient actors are able to read the *updated* snapshot value of the sender\n  actorScope.defer(() => {\n    const {\n      to,\n      event,\n      delay,\n      id\n    } = params;\n    if (typeof delay === 'number') {\n      actorScope.system.scheduler.schedule(actorScope.self, to, event, delay, id);\n      return;\n    }\n    actorScope.system._relay(actorScope.self,\n    // at this point, in a deferred task, it should already be mutated by retryResolveSendTo\n    // if it initially started as a string\n    to, event.type === XSTATE_ERROR ? createErrorActorEvent(actorScope.self.id, event.data) : event);\n  });\n}\n/**\n * Sends an event to an actor.\n *\n * @param actor The `ActorRef` to send the event to.\n * @param event The event to send, or an expression that evaluates to the event to send\n * @param options Send action options\n *  - `id` - The unique send event identifier (used with `cancel()`).\n *  - `delay` - The number of milliseconds to delay the sending of the event.\n */\nfunction sendTo(to, eventOrExpr, options) {\n  function sendTo(args, params) {\n  }\n  sendTo.type = 'xsnapshot.sendTo';\n  sendTo.to = to;\n  sendTo.event = eventOrExpr;\n  sendTo.id = options?.id;\n  sendTo.delay = options?.delay;\n  sendTo.resolve = resolveSendTo;\n  sendTo.retryResolve = retryResolveSendTo;\n  sendTo.execute = executeSendTo;\n  return sendTo;\n}\n\n/**\n * Sends an event to this machine's parent.\n *\n * @param event The event to send to the parent machine.\n * @param options Options to pass into the send event.\n */\nfunction sendParent(event, options) {\n  return sendTo(SpecialTargets.Parent, event, options);\n}\n/**\n * Forwards (sends) an event to the `target` actor.\n *\n * @param target The target actor to forward the event to.\n * @param options Options to pass into the send action creator.\n */\nfunction forwardTo(target, options) {\n  return sendTo(target, ({\n    event\n  }) => event, options);\n}\n\nfunction resolveEnqueueActions(actorScope, snapshot, args, actionParams, {\n  collect\n}) {\n  const actions = [];\n  const enqueue = function enqueue(action) {\n    actions.push(action);\n  };\n  enqueue.assign = (...args) => {\n    actions.push(assign(...args));\n  };\n  enqueue.cancel = (...args) => {\n    actions.push(cancel(...args));\n  };\n  enqueue.raise = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay`\n    actions.push(raise(...args));\n  };\n  enqueue.sendTo = (...args) => {\n    // for some reason it fails to infer `TDelay` from `...args` here and picks its default (`never`)\n    // then it fails to typecheck that because `...args` use `string` in place of `TDelay\n    actions.push(sendTo(...args));\n  };\n  enqueue.spawnChild = (...args) => {\n    actions.push(spawnChild(...args));\n  };\n  enqueue.stopChild = (...args) => {\n    actions.push(stopChild(...args));\n  };\n  enqueue.emit = (...args) => {\n    actions.push(emit(...args));\n  };\n  collect({\n    context: args.context,\n    event: args.event,\n    enqueue,\n    check: guard => evaluateGuard(guard, snapshot.context, args.event, snapshot),\n    self: actorScope.self,\n    system: actorScope.system\n  }, actionParams);\n  return [snapshot, undefined, actions];\n}\n/**\n * Creates an action object that will execute actions that are queued by the `enqueue(action)` function.\n *\n * @example\n  ```ts\n  import { createMachine, enqueueActions } from 'xstate';\n\n  const machine = createMachine({\n    entry: enqueueActions(({ enqueue, check }) => {\n      enqueue.assign({ count: 0 });\n\n      if (check('someGuard')) {\n        enqueue.assign({ count: 1 });\n      }\n\n      enqueue('someAction');\n    })\n  })\n  ```\n */\nfunction enqueueActions(collect) {\n  function enqueueActions(args, params) {\n  }\n  enqueueActions.type = 'xstate.enqueueActions';\n  enqueueActions.collect = collect;\n  enqueueActions.resolve = resolveEnqueueActions;\n  return enqueueActions;\n}\n\nfunction resolveLog(_, snapshot, actionArgs, actionParams, {\n  value,\n  label\n}) {\n  return [snapshot, {\n    value: typeof value === 'function' ? value(actionArgs, actionParams) : value,\n    label\n  }];\n}\nfunction executeLog({\n  logger\n}, {\n  value,\n  label\n}) {\n  if (label) {\n    logger(label, value);\n  } else {\n    logger(value);\n  }\n}\n/**\n *\n * @param expr The expression function to evaluate which will be logged.\n *  Takes in 2 arguments:\n *  - `ctx` - the current state context\n *  - `event` - the event that caused this action to be executed.\n * @param label The label to give to the logged expression.\n */\nfunction log(value = ({\n  context,\n  event\n}) => ({\n  context,\n  event\n}), label) {\n  function log(args, params) {\n  }\n  log.type = 'xstate.log';\n  log.value = value;\n  log.label = label;\n  log.resolve = resolveLog;\n  log.execute = executeLog;\n  return log;\n}\n\nexport { SpecialTargets as S, assign as a, enqueueActions as b, sendTo as c, emit as e, forwardTo as f, log as l, sendParent as s };\n"],"mappings":"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,CAAC;AACJ;AACA,SAASC,WAAWA,CAACnD,UAAU,EAAAoD,KAAA,EAE5B;EAAA,IAF8B;IAC/BlD;EACF,CAAC,GAAAkD,KAAA;EACCpD,UAAU,CAACsB,KAAK,CAAC,MAAMtB,UAAU,CAACqD,IAAI,CAACnD,KAAK,CAAC,CAAC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmD,IAAIA;AACb;AACA;AACA;AACAJ,WAAW,EAAE;EACX,SAASI,IAAIA,CAACX,IAAI,EAAEC,MAAM,EAAE,CAC5B;EACAU,IAAI,CAACT,IAAI,GAAG,aAAa;EACzBS,IAAI,CAACnD,KAAK,GAAG+C,WAAW;EACxBI,IAAI,CAACR,OAAO,GAAGC,WAAW;EAC1BO,IAAI,CAACC,OAAO,GAAGH,WAAW;EAC1B,OAAOE,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIE,cAAc,GAAG,aAAa,UAAUA,cAAc,EAAE;EAC1DA,cAAc,CAAC,QAAQ,CAAC,GAAG,UAAU;EACrCA,cAAc,CAAC,UAAU,CAAC,GAAG,YAAY;EACzC,OAAOA,cAAc;AACvB,CAAC,CAAC,CAAC,CAAC,CAAC;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,aAAaA,CAACxD,UAAU,EAAE2B,QAAQ,EAAEe,IAAI,EAAEb,YAAY,EAAA4B,KAAA,EAK5DC,KAAK,EAAE;EAAA,IALuD;IAC/DC,EAAE;IACFzD,KAAK,EAAE+C,WAAW;IAClBhC,EAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}