{"ast":null,"code":"export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.esm.js';\nimport { S as STATE_DELIMITER, m as mapValues, t as toArray, f as formatTransitions, a as toTransitionConfigArray, b as formatTransition, N as NULL_EVENT, e as evaluateGuard, c as createInvokeId, g as getDelayedTransitions, d as formatInitialTransition, h as getCandidates, r as resolveStateValue, i as getAllStateNodes, j as getStateNodes, k as createMachineSnapshot, l as isInFinalState, n as macrostep, o as transitionNode, p as resolveActionsAndContext, q as createInitEvent, s as microstep, u as getInitialStateNodes, v as toStatePath, w as isStateId, x as getStateNodeByPath, y as getPersistedSnapshot, z as resolveReferencedActor, A as createActor, $ as $$ACTOR_TYPE } from './raise-29904799.esm.js';\nexport { B as Actor, I as __unsafe_getAllOwnEventDescriptors, E as and, M as cancel, A as createActor, j as getStateNodes, C as interpret, D as isMachineSnapshot, J as matchesState, F as not, G as or, K as pathToStateValue, O as raise, P as spawnChild, H as stateIn, Q as stop, R as stopChild, L as toObserver } from './raise-29904799.esm.js';\nimport { a as assign } from './log-86c89339.esm.js';\nexport { S as SpecialTargets, a as assign, e as emit, b as enqueueActions, f as forwardTo, l as log, s as sendParent, c as sendTo } from './log-86c89339.esm.js';\nimport '../dev/dist/xstate-dev.esm.js';\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort((_ref, _ref2) => {\n      let [_idA, timeoutA] = _ref;\n      let [_idB, timeoutB] = _ref2;\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the overall state value.\n     */\n    this.key = void 0;\n    /**\n     * The unique ID of the state node.\n     */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     *  - `'atomic'` - no child state nodes\n     *  - `'compound'` - nested child state nodes (XOR)\n     *  - `'parallel'` - orthogonal nested child state nodes (AND)\n     *  - `'history'` - history state node\n     *  - `'final'` - final state node\n     */\n    this.type = void 0;\n    /**\n     * The string path from the root machine node to this node.\n     */\n    this.path = void 0;\n    /**\n     * The child state nodes.\n     */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     *  - `'shallow'` - recalls only top-level historical state value\n     *  - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /**\n     * The action(s) to be executed upon entering the state node.\n     */\n    this.entry = void 0;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     */\n    this.exit = void 0;\n    /**\n     * The parent state node.\n     */\n    this.parent = void 0;\n    /**\n     * The root machine node.\n     */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(\"No initial state specified for compound state node \\\"#\".concat(this.id, \"\\\". Try adding { initial: \\\"\").concat(Object.keys(this.states)[0], \"\\\" } to the state config.\"));\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /**\n   * The well-structured state node definition.\n   */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => \"#\".concat(t.id)),\n          source: \"#\".concat(this.id),\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /**\n   * The logic invoked as actors by this state node.\n   */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      var _invokeConfig$id;\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = (_invokeConfig$id = invokeConfig.id) !== null && _invokeConfig$id !== void 0 ? _invokeConfig$id : createInvokeId(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : \"xstate.invoke.\".concat(createInvokeId(this.id, i));\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /**\n   * The mapping of events to transitions.\n   */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(_ref3 => {\n        let [descriptor, t] = _ref3;\n        return t.map(t => [descriptor, t]);\n      }).reduce((map, _ref4) => {\n        let [descriptor, transition] = _ref4;\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, \"candidates-\".concat(eventType), () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(\"Unable to evaluate guard \".concat(guardType ? \"'\".concat(guardType, \"' \") : '', \"in transition for event '\").concat(eventType, \"' in state node '\").concat(this.id, \"':\\n\").concat(err.message));\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /**\n   * All the event types accepted by this state node and its descendants.\n   */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(\"\".concat(event));\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, implementations) {\n    var _implementations$acto, _implementations$acti, _implementations$dela, _implementations$guar;\n    this.config = config;\n    /**\n     * The machine's own version.\n     */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    /**\n     * @deprecated an internal property that was acting as a \"phantom\" type, it's not used by anything right now but it's kept around for compatibility reasons\n     **/\n    this.__TResolvedTypesMeta = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: (_implementations$acto = implementations === null || implementations === void 0 ? void 0 : implementations.actors) !== null && _implementations$acto !== void 0 ? _implementations$acto : {},\n      actions: (_implementations$acti = implementations === null || implementations === void 0 ? void 0 : implementations.actions) !== null && _implementations$acti !== void 0 ? _implementations$acti : {},\n      delays: (_implementations$dela = implementations === null || implementations === void 0 ? void 0 : implementations.delays) !== null && _implementations$dela !== void 0 ? _implementations$dela : {},\n      guards: (_implementations$guar = implementations === null || implementations === void 0 ? void 0 : implementations.guards) !== null && _implementations$guar !== void 0 ? _implementations$guar : {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n  }\n\n  /**\n   * Clones this state machine with the provided implementations\n   * and merges the `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)\n   *  to recursively merge with the existing options.\n   *\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received `event`.\n   * Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`.\n   * Calculates a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps.\n   * This \"pre-initial\" state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = _ref5 => {\n        let {\n          spawn,\n          event,\n          self\n        } = _ref5;\n        return context({\n          spawn,\n          input: event.input,\n          self\n        });\n      };\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(\"Child state node '#\".concat(resolvedStateId, \"' does not exist on machine '\").concat(this.id, \"'\"));\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy\n * a predicate, and then resolves with that value.\n * Will throw if the desired state is not reached after an optional timeout.\n * (defaults to Infinity).\n *\n * @example\n * ```js\n * const state = await waitFor(someService, state => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value\n * that matches the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    let done = false;\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      sub.unsubscribe();\n      rej(new Error(\"Timeout of \".concat(resolvedOptions.timeout, \" ms exceeded\")));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      var _sub;\n      clearTimeout(handle);\n      done = true;\n      (_sub = sub) === null || _sub === void 0 || _sub.unsubscribe();\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(\"Actor terminated without satisfying predicate\"));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })` to provide machine implementations instead.\n *\n * @example\n  ```ts\n  import { createMachine } from 'xstate';\n\n  const lightMachine = createMachine({\n    id: 'light',\n    initial: 'green',\n    states: {\n      green: {\n        on: {\n          TIMER: { target: 'yellow' }\n        }\n      },\n      yellow: {\n        on: {\n          TIMER: { target: 'red' }\n        }\n      },\n      red: {\n        on: {\n          TIMER: { target: 'green' }\n        }\n      }\n    }\n  });\n\n  const lightActor = createActor(lightMachine);\n  lightActor.start();\n\n  lightActor.send({ type: 'TIMER' });\n  ```\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic) {\n  for (var _len = arguments.length, _ref6 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    _ref6[_key - 1] = arguments[_key];\n  }\n  let [input] = _ref6;\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on\n * the given `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the\n * `actorLogic` is used.\n *\n * @example\n  ```ts\n  import { getNextSnapshot } from 'xstate';\n  import { trafficLightMachine } from './trafficLightMachine.ts';\n\n  const nextSnapshot = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    undefined, // snapshot (or initial state if undefined)\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot.value);\n  // => 'yellow'\n\n  const nextSnapshot2 = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    nextSnapshot, // snapshot\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot2.value);\n  // =>'red'\n  ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup(_ref7) {\n  let {\n    schemas,\n    actors,\n    actions,\n    guards,\n    delays\n  } = _ref7;\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Asserts that the given event object is of the specified type or types.\n * Throws an error if the event object is not of the specified types.\n  @example\n\n  ```ts\n  // ...\n  entry: ({ event }) => {\n    assertEvent(event, 'doNothing');\n    // event is { type: 'doNothing' }\n  },\n  // ...\n  exit: ({ event }) => {\n    assertEvent(event, 'greet');\n    // event is { type: 'greet'; message: string }\n\n    assertEvent(event, ['greet', 'notify']);\n    // event is { type: 'greet'; message: string }\n    // or { type: 'notify'; message: string; level: 'info' | 'error' }\n  },\n  ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? \"type \\\"\".concat(types[0], \"\\\"\") : \"one of types \\\"\".concat(types.join('\", \"'), \"\\\"\");\n    throw new Error(\"Expected event \".concat(JSON.stringify(event), \" to have \").concat(typesText));\n  }\n}\nexport { SimulatedClock, StateMachine, StateNode, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, setup, toPromise, waitFor };","map":{"version":3,"names":["createEmptyActor","fromCallback","fromEventObservable","fromObservable","fromPromise","fromTransition","S","STATE_DELIMITER","m","mapValues","t","toArray","f","formatTransitions","a","toTransitionConfigArray","b","formatTransition","N","NULL_EVENT","e","evaluateGuard","c","createInvokeId","g","getDelayedTransitions","d","formatInitialTransition","h","getCandidates","r","resolveStateValue","i","getAllStateNodes","j","getStateNodes","k","createMachineSnapshot","l","isInFinalState","n","macrostep","o","transitionNode","p","resolveActionsAndContext","q","createInitEvent","s","microstep","u","getInitialStateNodes","v","toStatePath","w","isStateId","x","getStateNodeByPath","y","getPersistedSnapshot","z","resolveReferencedActor","A","createActor","$","$$ACTOR_TYPE","B","Actor","I","__unsafe_getAllOwnEventDescriptors","E","and","M","cancel","C","interpret","D","isMachineSnapshot","J","matchesState","F","not","G","or","K","pathToStateValue","O","raise","P","spawnChild","H","stateIn","Q","stop","R","stopChild","L","toObserver","assign","SpecialTargets","emit","enqueueActions","forwardTo","log","sendParent","sendTo","SimulatedClock","constructor","timeouts","Map","_now","_id","_flushing","_flushingInvalidated","now","getId","setTimeout","fn","timeout","id","set","start","clearTimeout","delete","time","Error","flushTimeouts","sorted","sort","_ref","_ref2","_idA","timeoutA","_idB","timeoutB","endA","endB","call","increment","ms","cache","WeakMap","memo","object","key","memoizedData","get","EMPTY_OBJECT","toSerializableAction","action","type","name","StateNode","config","options","path","states","history","entry","exit","parent","machine","meta","output","order","description","tags","transitions","always","_parent","_key","_machine","concat","join","Object","keys","length","idMap","size","stateConfig","stateNode","initial","slice","undefined","_initialize","map","forEach","definition","version","target","source","actions","eventType","reenter","toJSON","state","on","values","flat","invoke","invokeConfig","_invokeConfig$id","src","systemId","resolvedId","resolvedSrc","onDone","onError","invokeDefValues","flatMap","_ref3","descriptor","reduce","_ref4","transition","push","after","next","snapshot","event","selectedTransition","candidates","candidate","guard","resolvedContext","context","guardPassed","err","guardType","message","events","Set","ownEvents","stateId","add","Array","from","filter","some","STATE_IDENTIFIER","StateMachine","implementations","_implementations$acto","_implementations$acti","_implementations$dela","_implementations$guar","schemas","__xstatenode","root","__TResolvedTypesMeta","actors","delays","guards","bind","getInitialSnapshot","restoreSnapshot","provide","resolveState","resolvedStateValue","value","nodeSet","_nodes","children","status","error","historyValue","actorScope","microstates","getTransitionData","getPreInitialState","initEvent","internalQueue","preInitial","assignment","_ref5","spawn","self","input","preInitialState","nextState","macroState","child","getSnapshot","getStateNodeById","fullPath","relativePath","resolvedStateId","_actorScope","snapshotChildren","actorId","actorData","childState","logic","actorRef","syncSnapshot","restoredSnapshot","seen","reviveContext","contextPart","has","xstate$$type","defaultWaitForOptions","Infinity","waitFor","predicate","resolvedOptions","Promise","res","rej","done","handle","sub","unsubscribe","dispose","_sub","checkEmitted","emitted","subscribe","complete","createMachine","createInertActorScope","actorLogic","inertActorScope","defer","logger","sessionId","system","_len","arguments","_ref6","getNextSnapshot","_snapshot","setup","_ref7","toPromise","actor","resolve","reject","assertEvent","types","includes","typesText","JSON","stringify"],"sources":["C:/PoC-FE/video-fsm-dos-gitpages/node_modules/xstate/dist/xstate.esm.js"],"sourcesContent":["export { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition } from '../actors/dist/xstate-actors.esm.js';\nimport { S as STATE_DELIMITER, m as mapValues, t as toArray, f as formatTransitions, a as toTransitionConfigArray, b as formatTransition, N as NULL_EVENT, e as evaluateGuard, c as createInvokeId, g as getDelayedTransitions, d as formatInitialTransition, h as getCandidates, r as resolveStateValue, i as getAllStateNodes, j as getStateNodes, k as createMachineSnapshot, l as isInFinalState, n as macrostep, o as transitionNode, p as resolveActionsAndContext, q as createInitEvent, s as microstep, u as getInitialStateNodes, v as toStatePath, w as isStateId, x as getStateNodeByPath, y as getPersistedSnapshot, z as resolveReferencedActor, A as createActor, $ as $$ACTOR_TYPE } from './raise-29904799.esm.js';\nexport { B as Actor, I as __unsafe_getAllOwnEventDescriptors, E as and, M as cancel, A as createActor, j as getStateNodes, C as interpret, D as isMachineSnapshot, J as matchesState, F as not, G as or, K as pathToStateValue, O as raise, P as spawnChild, H as stateIn, Q as stop, R as stopChild, L as toObserver } from './raise-29904799.esm.js';\nimport { a as assign } from './log-86c89339.esm.js';\nexport { S as SpecialTargets, a as assign, e as emit, b as enqueueActions, f as forwardTo, l as log, s as sendParent, c as sendTo } from './log-86c89339.esm.js';\nimport '../dev/dist/xstate-dev.esm.js';\n\nclass SimulatedClock {\n  constructor() {\n    this.timeouts = new Map();\n    this._now = 0;\n    this._id = 0;\n    this._flushing = false;\n    this._flushingInvalidated = false;\n  }\n  now() {\n    return this._now;\n  }\n  getId() {\n    return this._id++;\n  }\n  setTimeout(fn, timeout) {\n    this._flushingInvalidated = this._flushing;\n    const id = this.getId();\n    this.timeouts.set(id, {\n      start: this.now(),\n      timeout,\n      fn\n    });\n    return id;\n  }\n  clearTimeout(id) {\n    this._flushingInvalidated = this._flushing;\n    this.timeouts.delete(id);\n  }\n  set(time) {\n    if (this._now > time) {\n      throw new Error('Unable to travel back in time');\n    }\n    this._now = time;\n    this.flushTimeouts();\n  }\n  flushTimeouts() {\n    if (this._flushing) {\n      this._flushingInvalidated = true;\n      return;\n    }\n    this._flushing = true;\n    const sorted = [...this.timeouts].sort(([_idA, timeoutA], [_idB, timeoutB]) => {\n      const endA = timeoutA.start + timeoutA.timeout;\n      const endB = timeoutB.start + timeoutB.timeout;\n      return endB > endA ? -1 : 1;\n    });\n    for (const [id, timeout] of sorted) {\n      if (this._flushingInvalidated) {\n        this._flushingInvalidated = false;\n        this._flushing = false;\n        this.flushTimeouts();\n        return;\n      }\n      if (this.now() - timeout.start >= timeout.timeout) {\n        this.timeouts.delete(id);\n        timeout.fn.call(null);\n      }\n    }\n    this._flushing = false;\n  }\n  increment(ms) {\n    this._now += ms;\n    this.flushTimeouts();\n  }\n}\n\nconst cache = new WeakMap();\nfunction memo(object, key, fn) {\n  let memoizedData = cache.get(object);\n  if (!memoizedData) {\n    memoizedData = {\n      [key]: fn()\n    };\n    cache.set(object, memoizedData);\n  } else if (!(key in memoizedData)) {\n    memoizedData[key] = fn();\n  }\n  return memoizedData[key];\n}\n\nconst EMPTY_OBJECT = {};\nconst toSerializableAction = action => {\n  if (typeof action === 'string') {\n    return {\n      type: action\n    };\n  }\n  if (typeof action === 'function') {\n    if ('resolve' in action) {\n      return {\n        type: action.type\n      };\n    }\n    return {\n      type: action.name\n    };\n  }\n  return action;\n};\nclass StateNode {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, options) {\n    this.config = config;\n    /**\n     * The relative key of the state node, which represents its location in the overall state value.\n     */\n    this.key = void 0;\n    /**\n     * The unique ID of the state node.\n     */\n    this.id = void 0;\n    /**\n     * The type of this state node:\n     *\n     *  - `'atomic'` - no child state nodes\n     *  - `'compound'` - nested child state nodes (XOR)\n     *  - `'parallel'` - orthogonal nested child state nodes (AND)\n     *  - `'history'` - history state node\n     *  - `'final'` - final state node\n     */\n    this.type = void 0;\n    /**\n     * The string path from the root machine node to this node.\n     */\n    this.path = void 0;\n    /**\n     * The child state nodes.\n     */\n    this.states = void 0;\n    /**\n     * The type of history on this state node. Can be:\n     *\n     *  - `'shallow'` - recalls only top-level historical state value\n     *  - `'deep'` - recalls historical state value at all levels\n     */\n    this.history = void 0;\n    /**\n     * The action(s) to be executed upon entering the state node.\n     */\n    this.entry = void 0;\n    /**\n     * The action(s) to be executed upon exiting the state node.\n     */\n    this.exit = void 0;\n    /**\n     * The parent state node.\n     */\n    this.parent = void 0;\n    /**\n     * The root machine node.\n     */\n    this.machine = void 0;\n    /**\n     * The meta data associated with this state node, which will be returned in State instances.\n     */\n    this.meta = void 0;\n    /**\n     * The output data sent with the \"xstate.done.state._id_\" event if this is a final state node.\n     */\n    this.output = void 0;\n    /**\n     * The order this state node appears. Corresponds to the implicit document order.\n     */\n    this.order = -1;\n    this.description = void 0;\n    this.tags = [];\n    this.transitions = void 0;\n    this.always = void 0;\n    this.parent = options._parent;\n    this.key = options._key;\n    this.machine = options._machine;\n    this.path = this.parent ? this.parent.path.concat(this.key) : [];\n    this.id = this.config.id || [this.machine.id, ...this.path].join(STATE_DELIMITER);\n    this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');\n    this.description = this.config.description;\n    this.order = this.machine.idMap.size;\n    this.machine.idMap.set(this.id, this);\n    this.states = this.config.states ? mapValues(this.config.states, (stateConfig, key) => {\n      const stateNode = new StateNode(stateConfig, {\n        _parent: this,\n        _key: key,\n        _machine: this.machine\n      });\n      return stateNode;\n    }) : EMPTY_OBJECT;\n    if (this.type === 'compound' && !this.config.initial) {\n      throw new Error(`No initial state specified for compound state node \"#${this.id}\". Try adding { initial: \"${Object.keys(this.states)[0]}\" } to the state config.`);\n    }\n\n    // History config\n    this.history = this.config.history === true ? 'shallow' : this.config.history || false;\n    this.entry = toArray(this.config.entry).slice();\n    this.exit = toArray(this.config.exit).slice();\n    this.meta = this.config.meta;\n    this.output = this.type === 'final' || !this.parent ? this.config.output : undefined;\n    this.tags = toArray(config.tags).slice();\n  }\n\n  /** @internal */\n  _initialize() {\n    this.transitions = formatTransitions(this);\n    if (this.config.always) {\n      this.always = toTransitionConfigArray(this.config.always).map(t => formatTransition(this, NULL_EVENT, t));\n    }\n    Object.keys(this.states).forEach(key => {\n      this.states[key]._initialize();\n    });\n  }\n\n  /**\n   * The well-structured state node definition.\n   */\n  get definition() {\n    return {\n      id: this.id,\n      key: this.key,\n      version: this.machine.version,\n      type: this.type,\n      initial: this.initial ? {\n        target: this.initial.target,\n        source: this,\n        actions: this.initial.actions.map(toSerializableAction),\n        eventType: null,\n        reenter: false,\n        toJSON: () => ({\n          target: this.initial.target.map(t => `#${t.id}`),\n          source: `#${this.id}`,\n          actions: this.initial.actions.map(toSerializableAction),\n          eventType: null\n        })\n      } : undefined,\n      history: this.history,\n      states: mapValues(this.states, state => {\n        return state.definition;\n      }),\n      on: this.on,\n      transitions: [...this.transitions.values()].flat().map(t => ({\n        ...t,\n        actions: t.actions.map(toSerializableAction)\n      })),\n      entry: this.entry.map(toSerializableAction),\n      exit: this.exit.map(toSerializableAction),\n      meta: this.meta,\n      order: this.order || -1,\n      output: this.output,\n      invoke: this.invoke,\n      description: this.description,\n      tags: this.tags\n    };\n  }\n\n  /** @internal */\n  toJSON() {\n    return this.definition;\n  }\n\n  /**\n   * The logic invoked as actors by this state node.\n   */\n  get invoke() {\n    return memo(this, 'invoke', () => toArray(this.config.invoke).map((invokeConfig, i) => {\n      const {\n        src,\n        systemId\n      } = invokeConfig;\n      const resolvedId = invokeConfig.id ?? createInvokeId(this.id, i);\n      const resolvedSrc = typeof src === 'string' ? src : `xstate.invoke.${createInvokeId(this.id, i)}`;\n      return {\n        ...invokeConfig,\n        src: resolvedSrc,\n        id: resolvedId,\n        systemId: systemId,\n        toJSON() {\n          const {\n            onDone,\n            onError,\n            ...invokeDefValues\n          } = invokeConfig;\n          return {\n            ...invokeDefValues,\n            type: 'xstate.invoke',\n            src: resolvedSrc,\n            id: resolvedId\n          };\n        }\n      };\n    }));\n  }\n\n  /**\n   * The mapping of events to transitions.\n   */\n  get on() {\n    return memo(this, 'on', () => {\n      const transitions = this.transitions;\n      return [...transitions].flatMap(([descriptor, t]) => t.map(t => [descriptor, t])).reduce((map, [descriptor, transition]) => {\n        map[descriptor] = map[descriptor] || [];\n        map[descriptor].push(transition);\n        return map;\n      }, {});\n    });\n  }\n  get after() {\n    return memo(this, 'delayedTransitions', () => getDelayedTransitions(this));\n  }\n  get initial() {\n    return memo(this, 'initial', () => formatInitialTransition(this, this.config.initial));\n  }\n\n  /** @internal */\n  next(snapshot, event) {\n    const eventType = event.type;\n    const actions = [];\n    let selectedTransition;\n    const candidates = memo(this, `candidates-${eventType}`, () => getCandidates(this, eventType));\n    for (const candidate of candidates) {\n      const {\n        guard\n      } = candidate;\n      const resolvedContext = snapshot.context;\n      let guardPassed = false;\n      try {\n        guardPassed = !guard || evaluateGuard(guard, resolvedContext, event, snapshot);\n      } catch (err) {\n        const guardType = typeof guard === 'string' ? guard : typeof guard === 'object' ? guard.type : undefined;\n        throw new Error(`Unable to evaluate guard ${guardType ? `'${guardType}' ` : ''}in transition for event '${eventType}' in state node '${this.id}':\\n${err.message}`);\n      }\n      if (guardPassed) {\n        actions.push(...candidate.actions);\n        selectedTransition = candidate;\n        break;\n      }\n    }\n    return selectedTransition ? [selectedTransition] : undefined;\n  }\n\n  /**\n   * All the event types accepted by this state node and its descendants.\n   */\n  get events() {\n    return memo(this, 'events', () => {\n      const {\n        states\n      } = this;\n      const events = new Set(this.ownEvents);\n      if (states) {\n        for (const stateId of Object.keys(states)) {\n          const state = states[stateId];\n          if (state.states) {\n            for (const event of state.events) {\n              events.add(`${event}`);\n            }\n          }\n        }\n      }\n      return Array.from(events);\n    });\n  }\n\n  /**\n   * All the events that have transitions directly from this state node.\n   *\n   * Excludes any inert events.\n   */\n  get ownEvents() {\n    const events = new Set([...this.transitions.keys()].filter(descriptor => {\n      return this.transitions.get(descriptor).some(transition => !(!transition.target && !transition.actions.length && !transition.reenter));\n    }));\n    return Array.from(events);\n  }\n}\n\nconst STATE_IDENTIFIER = '#';\nclass StateMachine {\n  constructor(\n  /**\n   * The raw config used to create the machine.\n   */\n  config, implementations) {\n    this.config = config;\n    /**\n     * The machine's own version.\n     */\n    this.version = void 0;\n    this.schemas = void 0;\n    this.implementations = void 0;\n    /** @internal */\n    this.__xstatenode = true;\n    /** @internal */\n    this.idMap = new Map();\n    this.root = void 0;\n    this.id = void 0;\n    this.states = void 0;\n    this.events = void 0;\n    /**\n     * @deprecated an internal property that was acting as a \"phantom\" type, it's not used by anything right now but it's kept around for compatibility reasons\n     **/\n    this.__TResolvedTypesMeta = void 0;\n    this.id = config.id || '(machine)';\n    this.implementations = {\n      actors: implementations?.actors ?? {},\n      actions: implementations?.actions ?? {},\n      delays: implementations?.delays ?? {},\n      guards: implementations?.guards ?? {}\n    };\n    this.version = this.config.version;\n    this.schemas = this.config.schemas;\n    this.transition = this.transition.bind(this);\n    this.getInitialSnapshot = this.getInitialSnapshot.bind(this);\n    this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this);\n    this.restoreSnapshot = this.restoreSnapshot.bind(this);\n    this.start = this.start.bind(this);\n    this.root = new StateNode(config, {\n      _key: this.id,\n      _machine: this\n    });\n    this.root._initialize();\n    this.states = this.root.states; // TODO: remove!\n    this.events = this.root.events;\n  }\n\n  /**\n   * Clones this state machine with the provided implementations\n   * and merges the `context` (if provided).\n   *\n   * @param implementations Options (`actions`, `guards`, `actors`, `delays`, `context`)\n   *  to recursively merge with the existing options.\n   *\n   * @returns A new `StateMachine` instance with the provided implementations.\n   */\n  provide(implementations) {\n    const {\n      actions,\n      guards,\n      actors,\n      delays\n    } = this.implementations;\n    return new StateMachine(this.config, {\n      actions: {\n        ...actions,\n        ...implementations.actions\n      },\n      guards: {\n        ...guards,\n        ...implementations.guards\n      },\n      actors: {\n        ...actors,\n        ...implementations.actors\n      },\n      delays: {\n        ...delays,\n        ...implementations.delays\n      }\n    });\n  }\n  resolveState(config) {\n    const resolvedStateValue = resolveStateValue(this.root, config.value);\n    const nodeSet = getAllStateNodes(getStateNodes(this.root, resolvedStateValue));\n    return createMachineSnapshot({\n      _nodes: [...nodeSet],\n      context: config.context || {},\n      children: {},\n      status: isInFinalState(nodeSet, this.root) ? 'done' : config.status || 'active',\n      output: config.output,\n      error: config.error,\n      historyValue: config.historyValue\n    }, this);\n  }\n\n  /**\n   * Determines the next snapshot given the current `snapshot` and received `event`.\n   * Calculates a full macrostep from all microsteps.\n   *\n   * @param snapshot The current snapshot\n   * @param event The received event\n   */\n  transition(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).snapshot;\n  }\n\n  /**\n   * Determines the next state given the current `state` and `event`.\n   * Calculates a microstep.\n   *\n   * @param state The current state\n   * @param event The received event\n   */\n  microstep(snapshot, event, actorScope) {\n    return macrostep(snapshot, event, actorScope).microstates;\n  }\n  getTransitionData(snapshot, event) {\n    return transitionNode(this.root, snapshot.value, snapshot, event) || [];\n  }\n\n  /**\n   * The initial state _before_ evaluating any microsteps.\n   * This \"pre-initial\" state is provided to initial actions executed in the initial state.\n   */\n  getPreInitialState(actorScope, initEvent, internalQueue) {\n    const {\n      context\n    } = this.config;\n    const preInitial = createMachineSnapshot({\n      context: typeof context !== 'function' && context ? context : {},\n      _nodes: [this.root],\n      children: {},\n      status: 'active'\n    }, this);\n    if (typeof context === 'function') {\n      const assignment = ({\n        spawn,\n        event,\n        self\n      }) => context({\n        spawn,\n        input: event.input,\n        self\n      });\n      return resolveActionsAndContext(preInitial, initEvent, actorScope, [assign(assignment)], internalQueue);\n    }\n    return preInitial;\n  }\n\n  /**\n   * Returns the initial `State` instance, with reference to `self` as an `ActorRef`.\n   */\n  getInitialSnapshot(actorScope, input) {\n    const initEvent = createInitEvent(input); // TODO: fix;\n    const internalQueue = [];\n    const preInitialState = this.getPreInitialState(actorScope, initEvent, internalQueue);\n    const nextState = microstep([{\n      target: [...getInitialStateNodes(this.root)],\n      source: this.root,\n      reenter: true,\n      actions: [],\n      eventType: null,\n      toJSON: null // TODO: fix\n    }], preInitialState, actorScope, initEvent, true, internalQueue);\n    const {\n      snapshot: macroState\n    } = macrostep(nextState, initEvent, actorScope, internalQueue);\n    return macroState;\n  }\n  start(snapshot) {\n    Object.values(snapshot.children).forEach(child => {\n      if (child.getSnapshot().status === 'active') {\n        child.start();\n      }\n    });\n  }\n  getStateNodeById(stateId) {\n    const fullPath = toStatePath(stateId);\n    const relativePath = fullPath.slice(1);\n    const resolvedStateId = isStateId(fullPath[0]) ? fullPath[0].slice(STATE_IDENTIFIER.length) : fullPath[0];\n    const stateNode = this.idMap.get(resolvedStateId);\n    if (!stateNode) {\n      throw new Error(`Child state node '#${resolvedStateId}' does not exist on machine '${this.id}'`);\n    }\n    return getStateNodeByPath(stateNode, relativePath);\n  }\n  get definition() {\n    return this.root.definition;\n  }\n  toJSON() {\n    return this.definition;\n  }\n  getPersistedSnapshot(snapshot, options) {\n    return getPersistedSnapshot(snapshot, options);\n  }\n  restoreSnapshot(snapshot, _actorScope) {\n    const children = {};\n    const snapshotChildren = snapshot.children;\n    Object.keys(snapshotChildren).forEach(actorId => {\n      const actorData = snapshotChildren[actorId];\n      const childState = actorData.snapshot;\n      const src = actorData.src;\n      const logic = typeof src === 'string' ? resolveReferencedActor(this, src) : src;\n      if (!logic) {\n        return;\n      }\n      const actorRef = createActor(logic, {\n        id: actorId,\n        parent: _actorScope.self,\n        syncSnapshot: actorData.syncSnapshot,\n        snapshot: childState,\n        src,\n        systemId: actorData.systemId\n      });\n      children[actorId] = actorRef;\n    });\n    const restoredSnapshot = createMachineSnapshot({\n      ...snapshot,\n      children,\n      _nodes: Array.from(getAllStateNodes(getStateNodes(this.root, snapshot.value)))\n    }, this);\n    let seen = new Set();\n    function reviveContext(contextPart, children) {\n      if (seen.has(contextPart)) {\n        return;\n      }\n      seen.add(contextPart);\n      for (let key in contextPart) {\n        const value = contextPart[key];\n        if (value && typeof value === 'object') {\n          if ('xstate$$type' in value && value.xstate$$type === $$ACTOR_TYPE) {\n            contextPart[key] = children[value.id];\n            continue;\n          }\n          reviveContext(value, children);\n        }\n      }\n    }\n    reviveContext(restoredSnapshot.context, children);\n    return restoredSnapshot;\n  }\n}\n\nconst defaultWaitForOptions = {\n  timeout: Infinity // much more than 10 seconds\n};\n\n/**\n * Subscribes to an actor ref and waits for its emitted value to satisfy\n * a predicate, and then resolves with that value.\n * Will throw if the desired state is not reached after an optional timeout.\n * (defaults to Infinity).\n *\n * @example\n * ```js\n * const state = await waitFor(someService, state => {\n *   return state.hasTag('loaded');\n * });\n *\n * state.hasTag('loaded'); // true\n * ```\n *\n * @param actorRef The actor ref to subscribe to\n * @param predicate Determines if a value matches the condition to wait for\n * @param options\n * @returns A promise that eventually resolves to the emitted value\n * that matches the condition\n */\nfunction waitFor(actorRef, predicate, options) {\n  const resolvedOptions = {\n    ...defaultWaitForOptions,\n    ...options\n  };\n  return new Promise((res, rej) => {\n    let done = false;\n    const handle = resolvedOptions.timeout === Infinity ? undefined : setTimeout(() => {\n      sub.unsubscribe();\n      rej(new Error(`Timeout of ${resolvedOptions.timeout} ms exceeded`));\n    }, resolvedOptions.timeout);\n    const dispose = () => {\n      clearTimeout(handle);\n      done = true;\n      sub?.unsubscribe();\n    };\n    function checkEmitted(emitted) {\n      if (predicate(emitted)) {\n        dispose();\n        res(emitted);\n      }\n    }\n    let sub; // avoid TDZ when disposing synchronously\n\n    // See if the current snapshot already matches the predicate\n    checkEmitted(actorRef.getSnapshot());\n    if (done) {\n      return;\n    }\n    sub = actorRef.subscribe({\n      next: checkEmitted,\n      error: err => {\n        dispose();\n        rej(err);\n      },\n      complete: () => {\n        dispose();\n        rej(new Error(`Actor terminated without satisfying predicate`));\n      }\n    });\n    if (done) {\n      sub.unsubscribe();\n    }\n  });\n}\n\n// this is not 100% accurate since we can't make parallel regions required in the result\n// `TTestValue` doesn't encode this information anyhow for us to be able to do that\n// this is fine for most practical use cases anyway though\n/**\n * Creates a state machine (statechart) with the given configuration.\n *\n * The state machine represents the pure logic of a state machine actor.\n *\n * @param config The state machine configuration.\n * @param options DEPRECATED: use `setup({ ... })` or `machine.provide({ ... })` to provide machine implementations instead.\n *\n * @example\n  ```ts\n  import { createMachine } from 'xstate';\n\n  const lightMachine = createMachine({\n    id: 'light',\n    initial: 'green',\n    states: {\n      green: {\n        on: {\n          TIMER: { target: 'yellow' }\n        }\n      },\n      yellow: {\n        on: {\n          TIMER: { target: 'red' }\n        }\n      },\n      red: {\n        on: {\n          TIMER: { target: 'green' }\n        }\n      }\n    }\n  });\n\n  const lightActor = createActor(lightMachine);\n  lightActor.start();\n\n  lightActor.send({ type: 'TIMER' });\n  ```\n */\nfunction createMachine(config, implementations) {\n  return new StateMachine(config, implementations);\n}\n\n/** @internal */\nfunction createInertActorScope(actorLogic) {\n  const self = createActor(actorLogic);\n  const inertActorScope = {\n    self,\n    defer: () => {},\n    id: '',\n    logger: () => {},\n    sessionId: '',\n    stopChild: () => {},\n    system: self.system,\n    emit: () => {}\n  };\n  return inertActorScope;\n}\nfunction getInitialSnapshot(actorLogic, ...[input]) {\n  const actorScope = createInertActorScope(actorLogic);\n  return actorLogic.getInitialSnapshot(actorScope, input);\n}\n\n/**\n * Determines the next snapshot for the given `actorLogic` based on\n * the given `snapshot` and `event`.\n *\n * If the `snapshot` is `undefined`, the initial snapshot of the\n * `actorLogic` is used.\n *\n * @example\n  ```ts\n  import { getNextSnapshot } from 'xstate';\n  import { trafficLightMachine } from './trafficLightMachine.ts';\n\n  const nextSnapshot = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    undefined, // snapshot (or initial state if undefined)\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot.value);\n  // => 'yellow'\n\n  const nextSnapshot2 = getNextSnapshot(\n    trafficLightMachine, // actor logic\n    nextSnapshot, // snapshot\n    { type: 'TIMER' }); // event object\n\n  console.log(nextSnapshot2.value);\n  // =>'red'\n  ```\n */\nfunction getNextSnapshot(actorLogic, snapshot, event) {\n  const inertActorScope = createInertActorScope(actorLogic);\n  inertActorScope.self._snapshot = snapshot;\n  return actorLogic.transition(snapshot, event, inertActorScope);\n}\n\n// at the moment we allow extra actors - ones that are not specified by `children`\n// this could be reconsidered in the future\nfunction setup({\n  schemas,\n  actors,\n  actions,\n  guards,\n  delays\n}) {\n  return {\n    createMachine: config => createMachine({\n      ...config,\n      schemas\n    }, {\n      actors,\n      actions,\n      guards,\n      delays\n    })\n  };\n}\n\n/**\n * Returns a promise that resolves to the `output` of the actor when it is done.\n *\n * @example\n * ```ts\n * const machine = createMachine({\n *   // ...\n *   output: {\n *     count: 42\n *   }\n * });\n *\n * const actor = createActor(machine);\n *\n * actor.start();\n *\n * const output = await toPromise(actor);\n *\n * console.log(output);\n * // logs { count: 42 }\n * ```\n */\nfunction toPromise(actor) {\n  return new Promise((resolve, reject) => {\n    actor.subscribe({\n      complete: () => {\n        resolve(actor.getSnapshot().output);\n      },\n      error: reject\n    });\n  });\n}\n\n/**\n * Asserts that the given event object is of the specified type or types.\n * Throws an error if the event object is not of the specified types.\n  @example\n\n  ```ts\n  // ...\n  entry: ({ event }) => {\n    assertEvent(event, 'doNothing');\n    // event is { type: 'doNothing' }\n  },\n  // ...\n  exit: ({ event }) => {\n    assertEvent(event, 'greet');\n    // event is { type: 'greet'; message: string }\n\n    assertEvent(event, ['greet', 'notify']);\n    // event is { type: 'greet'; message: string }\n    // or { type: 'notify'; message: string; level: 'info' | 'error' }\n  },\n  ```\n */\nfunction assertEvent(event, type) {\n  const types = toArray(type);\n  if (!types.includes(event.type)) {\n    const typesText = types.length === 1 ? `type \"${types[0]}\"` : `one of types \"${types.join('\", \"')}\"`;\n    throw new Error(`Expected event ${JSON.stringify(event)} to have ${typesText}`);\n  }\n}\n\nexport { SimulatedClock, StateMachine, StateNode, assertEvent, createMachine, getInitialSnapshot, getNextSnapshot, setup, toPromise, waitFor };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}