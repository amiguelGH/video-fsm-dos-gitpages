{"ast":null,"code":"import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-29904799.esm.js';\nimport '../../dev/dist/xstate-dev.esm.js';\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and received `event` object as arguments, and returns the next state, similar to a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial state argument, and is not the same as the State object of an actor or a state within a machine configuration.\n *\n * @param transition The transition function used to describe the transition logic. It should return the next state given the current state and event. It receives the following arguments:\n * - `state` - the current state.\n * - `event` - the received event.\n * - `actorScope` - the actor scope object, with properties like `self` and `system`.\n * @param initialContext The initial state of the transition function, either an object representing the state, or a function which returns a state object. If a function, it will receive as its only argument an object with the following properties:\n * - `input` - the `input` provided to its parent transition actor.\n * - `self` - a reference to its parent transition actor.\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n * @returns Actor logic\n *\n * @example\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1,\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 },\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\nconst instanceStates = /* #__PURE__ */new WeakMap();\n/**\n * An actor logic creator which returns callback logic as defined by a callback function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @param invokeCallback - The callback function used to describe the callback logic\n * The callback function is passed an object with the following properties:\n * - `receive` - A function that can send events back to the parent actor; the listener is then called whenever events are received by the callback actor\n * - `sendBack` - A function that can send events back to the parent actor\n * - `input` - Data that was provided to the callback actor\n * - `self` - The parent actor of the callback actor\n * - `system` - The actor system to which the callback actor belongs\n * The callback function can (optionally) return a cleanup function, which is called when the actor is stopped.\n * @see {@link InvokeCallback} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n\n * @returns Callback logic\n *\n * @example\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n */\nfunction fromCallback(invokeCallback) {\n  const logic = {\n    config: invokeCallback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = invokeCallback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          var _callbackState$receiv;\n          (_callbackState$receiv = callbackState.receivers) !== null && _callbackState$receiv !== void 0 ? _callbackState$receiv : callbackState.receivers = new Set();\n          callbackState.receivers.add(listener);\n        }\n      });\n    },\n    transition: (state, event, actorScope) => {\n      var _callbackState$receiv2;\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        var _callbackState$dispos;\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        (_callbackState$dispos = callbackState.dispose) === null || _callbackState$dispos === void 0 || _callbackState$dispos.call(callbackState);\n        return state;\n      }\n      (_callbackState$receiv2 = callbackState.receivers) === null || _callbackState$receiv2 === void 0 || _callbackState$receiv2.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n/**\n * Observable actor logic is described by an observable stream of values. Actors created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @param observableCreator A function that creates an observable. It receives one argument, an object with the following properties:\n * - `input` - Data that was provided to the observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the observable actor belongs\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import { fromObservable, createActor } from 'xstate'\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event, _ref) => {\n      let {\n        self,\n        id,\n        defer,\n        system\n      } = _ref;\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, _ref2) => {\n      let {\n        self,\n        system\n      } = _ref2;\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: _ref3 => {\n      let {\n        _subscription,\n        ...state\n      } = _ref3;\n      return state;\n    },\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers event objects.\n *\n * Event observable actor logic is described by an observable stream of {@link https://stately.ai/docs/transitions#event-objects | event objects}. Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @param lazyObservable A function that creates an observable that delivers event objects. It receives one argument, an object with the following properties:\n *\n * - `input` - Data that was provided to the event observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the event observable actor belongs.\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(() =>\n *   fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic,\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, _ref4) => {\n      let {\n        self,\n        system\n      } = _ref4;\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: _ref5 => {\n      let {\n        _subscription,\n        ...snapshot\n      } = _ref5;\n      return snapshot;\n    },\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n/**\n * An actor logic creator which returns promise logic as defined by an async process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @param promiseCreator\n *   A function which returns a Promise, and accepts an object with the following properties:\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n *\n * @example\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...')\n *     .then((data) => data.json());\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n */\n\nconst controllerMap = new WeakMap();\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            var _controllerMap$get;\n            (_controllerMap$get = controllerMap.get(scope.self)) === null || _controllerMap$get === void 0 || _controllerMap$get.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, _ref6) => {\n      let {\n        self,\n        system\n      } = _ref6;\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };","map":{"version":3,"names":["X","XSTATE_STOP","A","createActor","fromTransition","transition","initialContext","config","snapshot","event","actorScope","context","getInitialSnapshot","_","input","status","output","undefined","error","getPersistedSnapshot","restoreSnapshot","instanceStates","WeakMap","fromCallback","invokeCallback","logic","start","state","self","system","callbackState","receivers","dispose","set","sendBack","getSnapshot","_parent","_relay","receive","listener","_callbackState$receiv","Set","add","_callbackState$receiv2","get","type","_callbackState$dispos","call","forEach","receiver","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","fromObservable","observableCreator","_ref","id","defer","newSnapshot","data","_subscription","unsubscribe","_ref2","subscribe","next","value","err","complete","_ref3","fromEventObservable","lazyObservable","_ref4","_ref5","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","fromPromise","promiseCreator","scope","resolvedValue","_controllerMap$get","abort","_ref6","controller","AbortController","resolvedPromise","Promise","resolve","signal","then","response","delete","errorData","emptyLogic","createEmptyActor"],"sources":["C:/PoC-FE/video-fsm-dos-gitpages/node_modules/xstate/actors/dist/xstate-actors.esm.js"],"sourcesContent":["import { X as XSTATE_STOP, A as createActor } from '../../dist/raise-29904799.esm.js';\nimport '../../dev/dist/xstate-dev.esm.js';\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and received `event` object as arguments, and returns the next state, similar to a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial state argument, and is not the same as the State object of an actor or a state within a machine configuration.\n *\n * @param transition The transition function used to describe the transition logic. It should return the next state given the current state and event. It receives the following arguments:\n * - `state` - the current state.\n * - `event` - the received event.\n * - `actorScope` - the actor scope object, with properties like `self` and `system`.\n * @param initialContext The initial state of the transition function, either an object representing the state, or a function which returns a state object. If a function, it will receive as its only argument an object with the following properties:\n * - `input` - the `input` provided to its parent transition actor.\n * - `self` - a reference to its parent transition actor.\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n * @returns Actor logic\n *\n * @example\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1,\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 },\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n */\nfunction fromTransition(transition, initialContext) {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(snapshot.context, event, actorScope)\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: typeof initialContext === 'function' ? initialContext({\n          input\n        }) : initialContext\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n}\n\nconst instanceStates = /* #__PURE__ */new WeakMap();\n/**\n * An actor logic creator which returns callback logic as defined by a callback function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @param invokeCallback - The callback function used to describe the callback logic\n * The callback function is passed an object with the following properties:\n * - `receive` - A function that can send events back to the parent actor; the listener is then called whenever events are received by the callback actor\n * - `sendBack` - A function that can send events back to the parent actor\n * - `input` - Data that was provided to the callback actor\n * - `self` - The parent actor of the callback actor\n * - `system` - The actor system to which the callback actor belongs\n * The callback function can (optionally) return a cleanup function, which is called when the actor is stopped.\n * @see {@link InvokeCallback} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n\n * @returns Callback logic\n *\n * @example\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n */\nfunction fromCallback(invokeCallback) {\n  const logic = {\n    config: invokeCallback,\n    start: (state, actorScope) => {\n      const {\n        self,\n        system\n      } = actorScope;\n      const callbackState = {\n        receivers: undefined,\n        dispose: undefined\n      };\n      instanceStates.set(self, callbackState);\n      callbackState.dispose = invokeCallback({\n        input: state.input,\n        system,\n        self,\n        sendBack: event => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: listener => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        }\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState = instanceStates.get(actorScope.self);\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n        callbackState.dispose?.();\n        return state;\n      }\n      callbackState.receivers?.forEach(receiver => receiver(event));\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n/**\n * Observable actor logic is described by an observable stream of values. Actors created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @param observableCreator A function that creates an observable. It receives one argument, an object with the following properties:\n * - `input` - Data that was provided to the observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the observable actor belongs\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import { fromObservable, createActor } from 'xstate'\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nfunction fromObservable(observableCreator) {\n  // TODO: add event types\n  const logic = {\n    config: observableCreator,\n    transition: (snapshot, event, {\n      self,\n      id,\n      defer,\n      system\n    }) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT:\n          {\n            const newSnapshot = {\n              ...snapshot,\n              context: event.data\n            };\n            return newSnapshot;\n          }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...state\n    }) => state,\n    restoreSnapshot: state => ({\n      ...state,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers event objects.\n *\n * Event observable actor logic is described by an observable stream of {@link https://stately.ai/docs/transitions#event-objects | event objects}. Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @param lazyObservable A function that creates an observable that delivers event objects. It receives one argument, an object with the following properties:\n *\n * - `input` - Data that was provided to the event observable actor\n * - `self` - The parent actor\n * - `system` - The actor system to which the event observable actor belongs.\n *\n * It should return a {@link Subscribable}, which is compatible with an RxJS Observable, although RxJS is not required to create them.\n *\n * @example\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(() =>\n *   fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic,\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n */\nfunction fromEventObservable(lazyObservable) {\n  // TODO: event types\n  const logic = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = lazyObservable({\n        input: state.input,\n        system,\n        self\n      }).subscribe({\n        next: value => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: err => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_COMPLETE\n          });\n        }\n      });\n    },\n    getPersistedSnapshot: ({\n      _subscription,\n      ...snapshot\n    }) => snapshot,\n    restoreSnapshot: snapshot => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n  return logic;\n}\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n/**\n * An actor logic creator which returns promise logic as defined by an async process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @param promiseCreator\n *   A function which returns a Promise, and accepts an object with the following properties:\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n *\n * @example\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...')\n *     .then((data) => data.json());\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n */\n\nconst controllerMap = new WeakMap();\nfunction fromPromise(promiseCreator) {\n  const logic = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE:\n          {\n            const resolvedValue = event.data;\n            return {\n              ...state,\n              status: 'done',\n              output: resolvedValue,\n              input: undefined\n            };\n          }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: event.data,\n            input: undefined\n          };\n        case XSTATE_STOP:\n          {\n            controllerMap.get(scope.self)?.abort();\n            return {\n              ...state,\n              status: 'stopped',\n              input: undefined\n            };\n          }\n        default:\n          return state;\n      }\n    },\n    start: (state, {\n      self,\n      system\n    }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(promiseCreator({\n        input: state.input,\n        system,\n        self,\n        signal: controller.signal\n      }));\n      resolvedPromise.then(response => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_RESOLVE,\n          data: response\n        });\n      }, errorData => {\n        if (self.getSnapshot().status !== 'active') {\n          return;\n        }\n        controllerMap.delete(self);\n        system._relay(self, self, {\n          type: XSTATE_PROMISE_REJECT,\n          data: errorData\n        });\n      });\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: snapshot => snapshot,\n    restoreSnapshot: snapshot => snapshot\n  };\n  return logic;\n}\n\nconst emptyLogic = fromTransition(_ => undefined, undefined);\nfunction createEmptyActor() {\n  return createActor(emptyLogic);\n}\n\nexport { createEmptyActor, fromCallback, fromEventObservable, fromObservable, fromPromise, fromTransition };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,WAAW,EAAEC,CAAC,IAAIC,WAAW,QAAQ,kCAAkC;AACrF,OAAO,kCAAkC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,UAAU,EAAEC,cAAc,EAAE;EAClD,OAAO;IACLC,MAAM,EAAEF,UAAU;IAClBA,UAAU,EAAEA,CAACG,QAAQ,EAAEC,KAAK,EAAEC,UAAU,KAAK;MAC3C,OAAO;QACL,GAAGF,QAAQ;QACXG,OAAO,EAAEN,UAAU,CAACG,QAAQ,CAACG,OAAO,EAAEF,KAAK,EAAEC,UAAU;MACzD,CAAC;IACH,CAAC;IACDE,kBAAkB,EAAEA,CAACC,CAAC,EAAEC,KAAK,KAAK;MAChC,OAAO;QACLC,MAAM,EAAE,QAAQ;QAChBC,MAAM,EAAEC,SAAS;QACjBC,KAAK,EAAED,SAAS;QAChBN,OAAO,EAAE,OAAOL,cAAc,KAAK,UAAU,GAAGA,cAAc,CAAC;UAC7DQ;QACF,CAAC,CAAC,GAAGR;MACP,CAAC;IACH,CAAC;IACDa,oBAAoB,EAAEX,QAAQ,IAAIA,QAAQ;IAC1CY,eAAe,EAAEZ,QAAQ,IAAIA;EAC/B,CAAC;AACH;AAEA,MAAMa,cAAc,GAAG,eAAe,IAAIC,OAAO,CAAC,CAAC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}